package com.seek.collection.list;

import java.util.ArrayList;
import java.util.LinkedList;

public class ArrayListAndLinkedListDemo {
	private ArrayList<String> arrayList = new ArrayList<>();
	private LinkedList<String> linkedList = new LinkedList<>();
	private static int NUM = 11160000;
	
	public static void main(String[] args) {
		
		//尾部顺序添加数据 一般来说是ArrayList效率比较高。
		//但是这个结果很大不确定性！！！！，数组每次达到容量时，都会非配原来容量的一半。接下来的插入到尾部就很快了
		//链表每次都需要新分配一个节点的内存来存储元素。添加到尾部并不需要从头遍历链表，因为它内部已经保存了尾部元素的引用。直接添加到尾部就可以了
		//不同的数据量，会有不同的执行结果,NUM = 15160000时，array_tail_add 耗时:15068 list_tail_add 耗时:11874
		
		array_tail_add();
		list_tail_add();
		
//		array_get();
//		list_get();
	}

	private static void list_get() {
		LinkedList<String> linkedList = new LinkedList<>();
		//每次都是末尾添加数据
		for(int i=0;i<8000000;i++){
			linkedList.add("hello world"+i);
		}
		System.out.println("添加完数据了");
		long start = System.currentTimeMillis();
		System.out.println(linkedList.get(8000000/2));
		long end = System.currentTimeMillis();
		System.out.println("list_get 耗时:"+(end - start));

	}

	private static void array_get() {
		// TODO Auto-generated method stub
		ArrayList<String> arrayList = new ArrayList<>();
				
		//每次都是末尾添加数据
		for(int i=0;i<18000000;i++){
			arrayList.add("hello world"+i);
		}
		
		System.out.println("添加完数据了");
		long start = System.currentTimeMillis();
		System.out.println(arrayList.get(18000000-1000));
		long end = System.currentTimeMillis();
		System.out.println("array_get 耗时:"+(end - start));
	}

	private static void list_tail_add() {
		LinkedList<String> linkedList = new LinkedList<>();
		long start = System.currentTimeMillis();
		//每次都是末尾添加数据
		for(int i=0;i<NUM;i++){
			linkedList.add("hello world"+i);
		}
		long end = System.currentTimeMillis();
		System.out.println("list_tail_add 耗时:"+(end - start));
	}

	private static void array_tail_add() {
		ArrayList<String> arrayList = new ArrayList<>();
		
		long start = System.currentTimeMillis();
		
		//每次都是末尾添加数据
		for(int i=0;i<NUM;i++){
			arrayList.add("hello world"+i);
		}

		long end = System.currentTimeMillis();
		System.out.println("array_tail_add 耗时:"+(end - start));
	}

}
